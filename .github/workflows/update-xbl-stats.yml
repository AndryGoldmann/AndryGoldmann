name: Update XBL Stats

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  schedule:
    - cron: "0 0 * * *"
  workflow_dispatch:

permissions:
  contents: write  # Grants GITHUB_TOKEN write access for pushes

jobs:
  build:
    name: Update-XBL-stats
    runs-on: ubuntu-latest
    env:
      XBL_API_KEY: ${{ secrets.XBL_API_KEY }}
      XBL_XUID: ${{ secrets.XBL_XUID }}

    steps:
      - name: Set up Go 1.x
        uses: actions/setup-go@v2
        with:
          go-version: ^1.14
        id: go
      - name: Check out repo
        uses: actions/checkout@v2
      - uses: actions/setup-go@v2
      - name: Build XBL updater
        run: |-
          cat > main.go << 'EOF'
          package main

          import (
          	"encoding/json"
          	"fmt"
          	"io"
          	"net/http"
          	"os"
          	"regexp"
          	"sort"
          	"strconv"
          	"strings"
          )

          type Achievement struct {
          	TitleId        string `json:"titleId"`
          	Name           string `json:"name"`
          	ProgressValue  int    `json:"progressValue"`
          }

          type AchievementsResponse struct {
          	Achievements []Achievement `json:"achievements"`
          }

          type ActivityItem struct {
          	TitleAssociations []struct {
          		Name string `json:"name"`
          	} `json:"titleAssociations"`
          }

          type RecentActivity struct {
          	Items []ActivityItem `json:"items"`
          }

          func main() {
          	xblKey := os.Getenv("XBL_API_KEY")
          	xuid := os.Getenv("XBL_XUID")
          	if xblKey == "" || xuid == "" {
          		fmt.Println("Missing XBL_API_KEY or XBL_XUID env vars")
          		os.Exit(1)
          	}

          	client := &http.Client{}

          	// Fetch achievements for leaderboard
          	reqAch, _ := http.NewRequest("GET", fmt.Sprintf("https://xbl.io/api/v2/%s/achievements", xuid), nil)
          	reqAch.Header.Set("X-Authorization", xblKey)
          	respAch, err := client.Do(reqAch)
          	var achResp AchievementsResponse
          	topGames := make(map[string]int)  // gameName -> totalGamerscore
          	if err == nil && respAch.StatusCode == 200 {
          		defer respAch.Body.Close()
          		achBody, _ := io.ReadAll(respAch.Body)
          		fmt.Println("DEBUG - Achievements JSON:", string(achBody))  // Debug print
          		if err := json.Unmarshal(achBody, &achResp); err == nil {
          			for _, ach := range achResp.Achievements {
          				topGames[ach.Name] += ach.ProgressValue
          			}
          		} else {
          			fmt.Printf("XBL: Error parsing achievements: %v\n", err)
          		}
          	} else if err != nil {
          		fmt.Printf("XBL: Error fetching achievements: %v\n", err)
          	} else {
          		fmt.Printf("XBL: Achievements API error %d\n", respAch.StatusCode)
          	}

          	// Sort top 5 games by total gamerscore
          	var gameScores []struct {
          		Name     string
          		Score    int
          	}
          	for name, score := range topGames {
          		gameScores = append(gameScores, struct {
          			Name  string
          			Score int
          		}{Name: name, Score: score})
          	}
          	sort.Slice(gameScores, func(i, j int) bool { return gameScores[i].Score > gameScores[j].Score })
          	if len(gameScores) > 5 {
          		gameScores = gameScores[:5]
          	}
          	var leaderboardStr strings.Builder
          	leaderboardStr.WriteString("### XBL Gamerscore Leaderboard\n")
          	if len(gameScores) == 0 {
          		leaderboardStr.WriteString("No achievements found.\n")
          	} else {
          		for _, gs := range gameScores {
          			leaderboardStr.WriteString(fmt.Sprintf("- %s: %dG\n", gs.Name, gs.Score))
          		}
          	}

          	// Fetch recent activity for recent games
          	reqRec, _ := http.NewRequest("GET", fmt.Sprintf("https://xbl.io/api/v2/%s/activity/recent", xuid), nil)
          	reqRec.Header.Set("X-Authorization", xblKey)
          	respRec, err := client.Do(reqRec)
          	var recent RecentActivity
          	if err == nil && respRec.StatusCode == 200 {
          		defer respRec.Body.Close()
          		recBody, _ := io.ReadAll(respRec.Body)
          		fmt.Println("DEBUG - Recent Activity JSON:", string(recBody))  // Debug print
          		if err := json.Unmarshal(recBody, &recent); err != nil {
          			fmt.Printf("XBL: Error parsing recent activity: %v\n", err)
          		}
          	} else if err != nil {
          		fmt.Printf("XBL: Error fetching recent activity: %v\n", err)
          	} else {
          		fmt.Printf("XBL: Recent activity API error %d\n", respRec.StatusCode)
          	}

          	// Collect recent games (first 5 unique)
          	games := make(map[string]bool)
          	var recentList []string
          	count := 0
          	for _, item := range recent.Items {
          		if count >= 5 {
          			break
          		}
          		for _, title := range item.TitleAssociations {
          			if !games[title.Name] {
          				games[title.Name] = true
          				recentList = append(recentList, fmt.Sprintf("- %s", title.Name))
          				count++
          				if count >= 5 {
          					break
          				}
          			}
          		}
          	}
          	var recentStr strings.Builder
          	recentStr.WriteString("### Recent XBL Games\n")
          	if len(recentList) == 0 {
          		recentStr.WriteString("No recent games found.\n")
          	} else {
          		for _, game := range recentList {
          			recentStr.WriteString(game + "\n")
          		}
          	}

          	// Read README.md
          	readme, err := os.ReadFile("README.md")
          	if err != nil {
          		fmt.Printf("XBL: Error reading README: %v\n", err)
          		os.Exit(1)
          	}
          	str := string(readme)

          	// Replace leaderboard markers
          	reLb := regexp.MustCompile(`(?s)<!-- xbl-leaderboard start -->.*?<!-- xbl-leaderboard end -->`)
          	newStr := reLb.ReplaceAllString(str, `<!-- xbl-leaderboard start -->`+leaderboardStr.String()+`<!-- xbl-leaderboard end -->`)

          	// Replace recent markers
          	reRec := regexp.MustCompile(`(?s)<!-- xbl-recent start -->.*?<!-- xbl-recent end -->`)
          	newStr = reRec.ReplaceAllString(newStr, `<!-- xbl-recent start -->`+recentStr.String()+`<!-- xbl-recent end -->`)

          	// Write back
          	if err := os.WriteFile("README.md", []byte(newStr), 0644); err != nil {
          		fmt.Printf("XBL: Error writing README: %v\n", err)
          		os.Exit(1)
          	}

          	fmt.Println("XBL: README updated with lists!")
          }
          EOF
          go mod init xbl-updater
          go mod tidy
          go build -o xbl main.go
          rm -f main.go go.mod go.sum
      - name: Update README with XBL stats
        run: ./xbl
      - name: Commit and push
        run: |-
          git config --global user.email "bot@github.com" && git config --global user.name "XBL-Bot"
          git config --global pull.rebase false
          git diff
          git add README.md && git commit -m "Update XBL lists" || exit 0
          git pull && git push
